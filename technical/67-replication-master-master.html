<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>[System Design] 07. Replication: phương pháp Master-master | Minh Nhật’s blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="[System Design] 07. Replication: phương pháp Master-master" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Multileader hay master-master 1 phương pháp thiết lập replication. Tương tự với master-slave, nhưng multimaster cho phép ghi dữ liệu trên nhiều node khác nhau. Sau đó, sẽ thực hiện xử lý conflict khi có concurrent write." />
<meta property="og:description" content="Multileader hay master-master 1 phương pháp thiết lập replication. Tương tự với master-slave, nhưng multimaster cho phép ghi dữ liệu trên nhiều node khác nhau. Sau đó, sẽ thực hiện xử lý conflict khi có concurrent write." />
<link rel="canonical" href="/technical/67-replication-master-master" />
<meta property="og:url" content="/technical/67-replication-master-master" />
<meta property="og:site_name" content="Minh Nhật’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-12-29T00:02:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="[System Design] 07. Replication: phương pháp Master-master" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-12-29T00:02:00+00:00","datePublished":"2023-12-29T00:02:00+00:00","description":"Multileader hay master-master 1 phương pháp thiết lập replication. Tương tự với master-slave, nhưng multimaster cho phép ghi dữ liệu trên nhiều node khác nhau. Sau đó, sẽ thực hiện xử lý conflict khi có concurrent write.","headline":"[System Design] 07. Replication: phương pháp Master-master","mainEntityOfPage":{"@type":"WebPage","@id":"/technical/67-replication-master-master"},"url":"/technical/67-replication-master-master"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Minh Nhật&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Minh Nhật&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <!-- <div class="trigger"><a class="page-link" href="/404.html"></a><a class="page-link" href="/about/">Về tôi</a><a class="page-link" href="/art">art</a><a class="page-link" href="/finance">Finance</a><a class="page-link" href="/"></a><a class="page-link" href="/assets/main.css"></a><a class="page-link" href="/opinion">opinion</a><a class="page-link" href="/philosophy">Philosophy</a><a class="page-link" href="/technical">technical</a><a class="page-link" href="/art">art</a><a class="page-link" href="/art/">art</a><a class="page-link" href="/finance">Finance</a><a class="page-link" href="/finance/">Finance</a><a class="page-link" href="/"></a><a class="page-link" href="/"></a><a class="page-link" href="/page1/"></a><a class="page-link" href="/page2/"></a><a class="page-link" href="/page3/"></a><a class="page-link" href="/page4/"></a><a class="page-link" href="/opinion">opinion</a><a class="page-link" href="/opinion/">opinion</a><a class="page-link" href="/philosophy">Philosophy</a><a class="page-link" href="/philosophy/">Philosophy</a><a class="page-link" href="/technical">technical</a><a class="page-link" href="/technical/">technical</a><a class="page-link" href="/feed.xml"></a></div> -->
        <div class="trigger">
          <a class="page-link" href="/philosophy">Triết học</a>
          <a class="page-link" href="/art">Văn, thơ, nhạc</a>
          <a class="page-link" href="/opinion">Góc nhìn cá nhân</a>
          <a class="page-link" href="/technical">IT</a>
          <a class="page-link" href="/finance">Finance</a>
          <a class="page-link" href="/about">Về tôi</a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">67. [System Design] 07. Replication: phương pháp  Master-master</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-12-29T00:02:00+00:00" itemprop="datePublished">Dec 29, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Multileader hay master-master 1 phương pháp thiết lập replication. Tương tự với master-slave, nhưng multimaster cho phép ghi dữ liệu trên nhiều node khác nhau. Sau đó, sẽ thực hiện xử lý conflict khi có concurrent write.</p>

<p><strong>Note</strong>: phương pháp này thường không được sử dụng rộng rãi và nên tránh khi có thể.</p>

<h2 id="use-case-for-multi-leader-replication">Use case for Multi-leader replication</h2>
<p>Thông thường, multi-leader không được dùng nếu chỉ giới hạn trong 1 datacenter, vì lợi ích đạt được nhỏ hơn rất nhiều so với mức độ phức tạp được thêm vào. Tuy nhiên, có 1 vài trường hợp, ta có thể xem xét dùng multi-leader replication</p>

<h3 id="multi-datacenter-operation">Multi-datacenter operation</h3>
<p>Giả sử bạn có nhiều datacenter và muốn replicate data tới nhiều datacenter khác nhau (có lẽ có thể chịu đựng việc toàn bộ 1 datacenter bị fail). Với single master-slave replication, master sẽ chỉ ở trong 1 datacenter.</p>

<p><img src="/assets/images/2023/67-multi-leader-replication.png" alt="Multileader replication" /></p>

<p>So sánh giữa single-leader và multi-leader config:</p>
<ul>
  <li>Performance: Với single leader config, mỗi write request đều phải đi đến datacenter chứa leader, và điều này làm gia tăng đáng kể latency. Với multi-leader config, write request có thể xử lý ở local datacenter và sau đó được replicate asynchornously tới những data center khác. Việc xử lý giữa các datacenter thì bị “ẩn” với người dùng, nên hiệu suất tốt hơn</li>
  <li>Tolerence of datacenter outages:</li>
  <li>Tolerance of network problems:</li>
</ul>

<p>Tuy nhiên, multi-leader cũng có 1 hạn chế rất lớn: nếu dữ liệu được thay đổi cùng lúc ở 2 datacenter khác nhau, conflict sẽ xảy ra và ta phải xử lý conflict này.</p>

<p>Ngoài ra, những thứ như auto-increament key, triggers, stored proceudure cũng có thể xảy ra vấn đề. <strong>Vì vậy, multi-leader replication thường không được sử dụng và nên tránh khi có thể.</strong></p>

<h3 id="clients-with-offline-operation">Clients with offline operation</h3>
<p>Đây là 1 dạng ứng dụng có thể tiếp tục hoạt động offline trong khi không kết nối với internet. Ví dụ calendar app, google docs, … Nếu có những thay đổi nào diễn ra offline, chúng cần được sync với server và những thiết bị khác khi chúng online</p>

<p>Trong trường hợp này, mỗi một thiết bị là 1 local database và hoạt động như một leader (chúng nhận write requests) và sẽ có quá trình sync dữ liệu giữa các device. Quá trình sync này (hay còn gọi là multi-leader replication process) có thể là async. The replication lag có thể là hàng giờ hoặc vài ngày, phụ thuộc vào việc khi nào thiết bị online</p>

<p>Từ góc nhìn của kiến trúc hệ thống, thiết lập như này giống với multi-leader replication giữa các datacenter, mà mỗi device là 1 datacenter. Với lịch sử phong phú của việc thất bại trong lúc sync calendar, nó chứng mình rằng multi-leader replication rất khó để hiện thực cách đúng đắn.</p>

<h3 id="collaborative-editing">Collaborative editing</h3>
<p>Real-time collaborative editing application cho phép nhiều người edit 1 document đồng thời. Ví dụ Google Docs.</p>

<p>Tác giả không nghĩ rằng collaborative editing là database replication problem, nhưng có nhiều điểm chung với trường hợp offline editing. Khi 1 user edit 1 document, sự thay đổi ngay lập tức được áp dụng tới local replica (trạng thái của document được lưu tạm thời trên web browser hoặc client application) và async replicated tới server hoặc những user khác đang edit cùng document</p>

<p>Nếu muốn đảm bảo không có editing confliect, ứng dụng cần duy trì lock với document trước khi 1 user có thể edit. Nếu 1 user khác muốn edit, trước tiên, họ cần phải đợi user đang giữ lock, commit những thay đổi và release lock. Mô hình này giống với single-leader replication with transaction trên leader</p>

<p>Tuy nhiên, để faster collaboration, bạn cần những thay đổi phải nhỏ (ví dụ: a single keystroke) và tránh locking. Phương pháp này cho phép nhiều user edit đồng thời, nhưng cũng mang đến những vấn đề của multi-leader replication, bao gồm việc xử lý conflict.</p>

<h3 id="handling-write-conflicts">Handling Write Conflicts</h3>
<p>Giả sử, User 1 thay đổi title từ A sang B. User thay đổi title từ A sang C cùng thời điểm. Mỗi thay đổi đều thành công trên local leader. Tuy nhiên, khi sự thay đổi async replicated, conflict xảy ra. Xem hình dưới</p>

<p><img src="/assets/images/2023/67-write-conflict.png" alt="write conflict" /></p>

<h3 id="synchronous-vs-asynchronous-confliect-detection">Synchronous vs Asynchronous confliect detection</h3>

<p>Với single leader database, với write request thứ 2, hoặc là sẽ block và đợt write request thứ 1 xong, hoặc là sẽ abort (bỏ) write request 2 và force user gọi lại request 2. Với multi leader, vì write đã thành công trên leader, nên conflict chỉ được phát hiện sau đó, khi async replicated xảy ra. Và có lẽ đã qúa trễ để user xử lý conflict</p>

<p>Theo lý thuyết, với multi-leader, ta có thể đợi dữ liệu replicated tới toàn bộ node trước khi xác nhận write request thành công. Tuy nhiên, điều này làm mất đi lợi thế của multi-leader replication.</p>

<h3 id="converging-toward-a-consistent-state">Converging toward a consistent state</h3>
<p>Với single-leader database, write request có sequential order. Nếu có nhiều update tới cùng 1 field, update cuối dùng sẽ xác định giá trị của field đó. Tôi nghĩ, thật ra vấn sẽ có concurrent write request tới leader, nhưng leader database sẽ tự xử lý việc này, nên chúng ta không cần quan tâm tới vấn đề này.</p>

<p>Với multi-leader mode, không có bất kỳ thứ tự gì cho việc write, do đó, ta không biết chính xác final value là gì. Trở lại ví dụ về write conflict, ta không biết sau cùng giá trị của title sẽ là B hay C ? Ta cần phải đảm bảo giá trị của từng replica là giống nhau, hay hội tụ là 1 giá trị (convergent). Có nhiều cách để thực hiện như:</p>
<ul>
  <li>Với mỗi write request, assign 1 unique ID (ex: a timestamp, long random number hoặc UUID,…), chọn write request mà ID là lớn nhất và đó là winner. Nếu timestamp được sử dụng, kỹ thuật này gọi là last write wins (LWW). Mặc dù kỹ thuật này phổ biến, nhưng cũng nguy hiểm vì dễ bị mất dữ liệu.</li>
  <li>Với mỗi replica, assign 1 unique ID (ở trên là assign ID cho write request, còn ở đây là assing ID cho mỗi replica), và luôn chọn replica có ID lớn hơn. Phương pháp này cũng gây ra data loss</li>
  <li>Merge value với nhau. Ví dụ sort theo alphabet và concat value. Với ví dụ ở trên, giá trị sau khi merge B và C là B/C</li>
  <li>Ghi nhận conflict và giữ lại toàn bộ data. Sau đó để application xử lý conflict ở 1 thời điểm nào đó.</li>
</ul>

<p>Những cách này quá chung chung, có thể xem như keyword để tìm hiểu thêm.</p>

<h3 id="custom-conflict-resolution-logic">Custom conflict resolution logic</h3>
<p>Conflict resolution có thể được xử lý ở applicaiton logic. Code có thể thực thi ở write hoặc read.</p>
<ul>
  <li>On write: Ngay khi database phát hiện conflict ở log of replicated changes, nó gọi là conflict handler.</li>
  <li>On read: Khi một conflict được phát hiện, tất cả các conflict đều được ghi vào database. Lần tới, khi data được đọc, sẽ có nhiều version của data được trả về. Ứng dụng có thể tự động xử lý hoặc cho phép user xử lý conflict, và sau đó ghi ngược lại vào database. CouchDB sử dụng phương pháp này</li>
</ul>

<p>Conflict resolution thường áp dụng ở mức individual row hoặc document, không phải toàn bộ transaction. Nếu 1 transaction có nhiều lệnh write, mỗi lệnh write sẽ được xem xử lý conflict riêng biệt.</p>

<p>Lưu ý rằng việc xử lý conflict sẽ nhanh chóng trở nên phức tạp và dễ dàng xảy ra lỗi.</p>

<p><strong>Referenes:</strong></p>
<ol>
  <li><a href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321">Book: Designing Data-Intensive Applications</a></li>
</ol>

  </div><a class="u-url" href="/technical/67-replication-master-master" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Contact</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Minh Nhật&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
